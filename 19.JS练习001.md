# JS 练习 001

## 作业

### 1. 数据类型&判断

#### 1.1. 数据类型

- Number
- String
- Boolean
- Undefined
- Null
- Symbol
- BigInt
- Object

#### 1.2. 类型判断

- typeof

  ```javascript
  typeof 123 //number
  typeof true //boolean
  typeof "abc" //string
  typeof undefined //undefined
  typeof null //object
  typeof 123n //bigint
  typeof Symbol(a) //symbol
  typeof [] //object
  typeof {} //object
  typeof function () {} //function
  typeof NaN //number
  typeof new Date() //object
  typeof RegExp() //object
  ```

- instanceof

  ```javascript
  function Person() {}
  const p = new Person()
  console.log(p instanceof Person) //true
  console.log(p instanceof Object) //true
  ```

- constructor

  ```javascript
  function Person() {}
  const p = new Person()
  console.log(p.constructor === Person) //true
  ```

- Array

  ```javascript
  Array.isArray([]) //true
  ```

- NaN

  ```javascript
  isNaN(NaN) //true
  isNaN(123) //false
  isNaN("abc") //true
  ```

- prototype

  ```javascript
  Object.prototype.toString.call(123) //[object Number]
  Object.prototype.toString.call("abc") //[object String]
  Object.prototype.toString.call(true) //[object Boolean]
  Object.prototype.toString.call(undefined) //[object Undefined]
  Object.prototype.toString.call(null) //[object Null]
  Object.prototype.toString.call(Symbol()) //[object Symbol]
  Object.prototype.toString.call(123n) //[object BigInt]
  Object.prototype.toString.call([]) //[object Array]
  Object.prototype.toString.call({}) //[object Object]
  Object.prototype.toString.call(function () {}) //[object Function]
  Object.prototype.toString.call(new Date()) //[object Date]
  Object.prototype.toString.call(RegExp()) //[object RegExp]
  ```

#### 1.3. 判断是否相等

- 全等

```javascript
null == undefined //true
null === undefined //false
NaN == NaN //false
;+0 === 0 //true
;+0 === -0 //true
```

- Object.is

```javascript
Object.is(null, undefined) //false
Object.is(NaN, NaN) //true
Object.is(+0, 0) //true
Object.is(-0, 0) //false
Object.is(+0, -0) //false
```

#### 1.4. 判断是否为空

```javascript
//判断是否为null
value === null
!value && typeof value != "undefined" && value != 0

//判断是否为空
!value //判断null undefine NaN 0 false ""
value.length === 0 //判断[]

//Object.getOwnPropertyNames 判断{}
var value = {}
var arr = Object.getOwnPropertyNames(value)
console.log(arr.length == 0) // true

//Object.getOwnPropertySymbols 判断Symbol()
var value = {}
var arr = Object.getOwnPropertySymbols(value)
console.log(arr.length == 0) // false
```

### 2. 构造函数&原型&实例&类

#### 2.1. 关系

//1.构造函数

```javascript
function Person(name, age) {
  this.name = name
  this.age = age
  this.sayName = function () {
    console.log(this.name)
  }
}

const p = new Person("Jim Green", 12)
```

//2. 构造函数的原型

```javascript
javascript
Person.prototype.job = "student"
```

//4. 关系

```javascript
javascript
p instanceof Person //true
p.__proto__ === Person.prototype //true
Person.prototype.constructor === Person // true
Person.prototype.isPrototypeOf(p) //true
```

#### 2.2. 继承
##### 2.2.1. 原型继承
```javascript
function SuperType(name,age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
        console.log(this.name)
    }
}

function SubType(){
    
}

SubType.prototype = new SuperType()

const sub = new SubType();

console.log(sub instanceof SubType); //true
console.log(sub instanceof SuperType); //true
```
##### 2.2.2. 经典继承
```javascript
function SuperType(name,age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
        console.log(this.name)
    }
}

function SubType(name, age){
    SuperType.call(this, name, age)
}

const sub = new SubType('Jim Green',12);
console.log(sub.name); //Jim Green
sub.sayName(); //Jim Green
console.log(sub instanceof SubType); //true
console.log(sub instanceof SuperType); //false
```
##### 2.2.3. 组合继承
```javascript
function SuperType(name,age){
    this.name = name;
    this.age = age;
    this.sayName = function(){
        console.log(this.name)
    }
}
SuperType.prototype.sayAge = function(){
    console.log(this.age)
}

function SubType(name, age, job){
    SuperType.call(this, name, age)
    this.job = job
}

SubType.prototype = new SuperType();
SubType.prototype.sayJob = function(){
    console.log(this.job)
}
const sub = new SubType('Jim Green',12,'student');
console.log(sub.name); //Jim Green
sub.sayName(); //Jim Green
sub.sayAge(); //12
sub.sayJob(); //student
console.log(sub instanceof SubType); //true
console.log(sub instanceof SuperType); //true
```
##### 2.2.4. 原型式继承
```javascript
function object(o){
    function F(){}
    F.prototype = o
    return new F()
}

let person = { 
 name: "Nicholas", 
 friends: ["Shelby", "Court", "Van"] 
}; 
let anotherPerson = object(person); 
anotherPerson.name = "Greg"; 
anotherPerson.friends.push("Rob"); 
let yetAnotherPerson = object(person); 
yetAnotherPerson.name = "Linda"; 
yetAnotherPerson.friends.push("Barbie"); 
console.log(person.friends);// ['Shelby', 'Court', 'Van', 'Rob', 'Barbie']
```
##### 2.2.5. 寄生式组合继承
```javascript
function object(o){
    function F(){}
    F.prototype = o
    return new F()
}

function inheritPrototype(subType,superType){
    let prototype = object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}
```

#### 2.3. 类
##### 2.3.1. 类的构成
```javascript
class Foo{
    constructor(name,age){
      this.name = name ;
      this.age = age;
    }
    sayName(){
      console.log(this.name)
    }
    static baseF(){
      console.log(this)
    }
}

const f = new Foo('Jim Green',12)
console.log(f.name); // Jim Green
f.sayName(); // Jim Green
Foo.baseF(); // class Foo{...}
typeof Foo ; // funciton 
```
##### 2.3.2. 类继承
```javascript
class Super{
    constructor(name,age){
      this.name = name ;
      this.age = age;
    }
    sayName(){
      console.log(this.name)
    }
    static baseF(){
      console.log(this)
    }
}
class Sub extends Super{
    constructor(name,age,job){
        super(name,age);
        this.job = job; 
        console.log(this.name)
    }
}

const s = new Sub('Jim Green',12, 'student');//Jim Green
console.log(s.age); //12
console.log(s.job); //student
s.sayName(); //Jim Green
Sub.baseF(); //class Sub{...}
```

### 3. 数组遍历
+ for循环
```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let i = 0, len = arr.length ; i < len ; i++ ){
    console.log(arr[i]);
}
```
+ forEach
```javascript
let arr = [2,3,5,7,11,13,17,19];
arr.forEach(function(item,index,arr){
    console.log(item)
})
```
+ for...in
```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let index in arr){
    console.log(arr[index]);
}
```
+ for...of
```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let item of arr){
    console.log(item);
}
```
+ Object.entries
```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let [index,item] of arr.entries()){
    console.log(index,item);
}
```
+ Object.keys()
 ```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let index of arr.keys()){
    console.log(index);
}
```
+ Object.values()
 ```javascript
let arr = [2,3,5,7,11,13,17,19];
for(let item of arr.values()){
    console.log(item);
}
```


### 4. 对象遍历

+ for-in 循环——只遍历可枚举属性，包含实例属性和原型属性
```javascript
const obj = {
    a:123,
    b:'abc',
    c:function(){
        console.log()
    }
}
for( let key in obj){
    console.log(obj[key])
}
```
+ Object.keys()——只遍历可枚举属性，只包含实例属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  }
}
const res = Object.keys(obj)
console.log(res)
```
+ Object.values()——只遍历可枚举属性，只包含实例属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  }
}
const res = Object.values(obj)
console.log(res)
```
+ Object.entries()——只遍历可枚举属性，只包含实例属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  }
}
const res = Object.entries(obj)
console.log(res)
```
+ Object.getOwnPropertyNames——遍历所有属性，除了Symbol属性，包含可枚举和不可枚举，包含实例属性和原型属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  },
  [Symbol()]:111
}
const res = Object.getOwnPropertyNames(obj)
console.log(res)
```
+ Object.getOwnPropertySymbols——只遍历Symbol属性，包含可枚举和不可枚举，包含实例属性和原型属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  },
  [Symbol()]:111
}
const res = Object.getOwnPropertySymbols(obj)
console.log(res)
```
+ Reflect.ownKeys——遍历所有属性，包含可枚举和不可枚举，包含实例属性和原型属性
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  },
  [Symbol()]:111
}
const res = Reflect.ownKeys(obj)
console.log(res)
```

### 5. 对象解构
```javascript
const obj = {
  a: 123,
  b: "abc",
  c: function () {
    console.log()
  },
  [Symbol()]:111
}
const {b,c,a} = obj
console.log(b,c,a)
```

### 6. 展开运算符
#### 6.1. 展开数组
```javascript
//数组转换
const arr = [1,2,3,4,5]
console.log(...arr) // 1 2 3 4 5

//数组浅拷贝
let a = [1, 2, 3, { m: 123 }]
let b = [...a]
console.log(b)
b[0] = 5
b[3].m = 456
console.log(a)
console.log(b)

//拼接数组
let a = [1, 2, 3]
let b = [-1, 0, ...a, 4, 5]
console.log(b)
```
#### 6.2. 展开函数
```javascript
function f(...args) {
  console.log(args)
}
f(1, 2, 3) //[1, 2, 3]

function f(a, ...args) {
  console.log(args)
}
f(1, 2, 3) //[2, 3]

function f(a, ...args, b) {
  console.log(args)
}
f(1, 2, 3) //SyntaxError: Rest parameter must be last formal parameter
```
#### 6.3. 展开对象
+ 对象浅拷贝
```javascript
//对象浅拷贝
let obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  },
  [Symbol()]: 1
}

let obj2 = { ...obj1 }
console.log(obj2) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 123 }, [Symbol()]: 1 }

obj2.a = 2
console.log(obj1) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 123 }, [Symbol()]: 1 }
console.log(obj2) //{ a: 2, b: 'xyz', c: [Function: c], d: { m: 123 }, [Symbol()]: 1 }

obj2.d.m = 456
console.log(obj1) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 456 }, [Symbol()]: 1 }
console.log(obj2) //{ a: 2, b: 'xyz', c: [Function: c], d: { m: 456 }, [Symbol()]: 1 }

```

+ 对象合并
```javascript
//合并对象
let obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  },
  [Symbol()]: 1
}

let obj2 = { ...obj1, e: 111 }
console.log(obj2)  //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 123 },  e: 111, [Symbol()]: 1 }

```
+ 对象解构
```javascript
let obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  },
  [Symbol()]: 1
}

let { a, b, ...obj2 } = obj1
console.log(obj2) //{ c: [Function: c], d: { m: 123 }, [Symbol()]: 1 }
```

### 7. Object 方法
+ Object.assign
```javascript
//浅拷贝
const obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  }
}

const obj2 = Object.assign(obj1)
console.log(obj2) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 123 } }

obj2.d.m = 456
console.log(obj1) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 456 } }
console.log(obj2) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 456 } }

//合并
const obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  }
}
const obj2 = {
  a: 2,
  b: "abc"
}
const obj3 = Object.assign(obj1, obj2)
console.log(obj3) //{ a: 2, b: 'abc', c: [Function: c], d: { m: 123 } }
```


+ Object.create
```javascript
//创建新对象，源对象是新对象的原型
const obj1 = {
  a: 1,
  b: "xyz",
  c: function () {},
  d: {
    m: 123
  }
}
const obj2 = Object.create(obj1)
console.log(obj2.a) //1

obj2.d.m = 456
console.log(obj1) //{ a: 1, b: 'xyz', c: [Function: c], d: { m: 456 } }
```

+ Object.defineProperty

```javascript
//对象添加属性
const obj = {}
Object.defineProperty(obj, "a", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 123
})
obj.a = 456
console.log(obj) //{a:456}
```
+ Object.defineProperties
```javascript
//对象多个属性
const obj = {}
Object.defineProperties(obj, {
  a: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: 123
  },
  b: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: {
      m: 10
    }
  }
})
console.log(obj) //{ a: 123, b: { m: 10 } }
```
+ Object.entries
```javascript
//返回对象可枚举属性的键值对数组
const obj = { a: 123, b: { m: 10 } }
const res = Object.entries(obj)
console.log(res) //[ [ 'a', 123 ], [ 'b', { m: 10 } ] ]
```
+ Object.fromEntries
```javascript
//键值对列表转换为一个对象
const obj = { a: 123, b: { m: 10 } }
const res = Object.entries(obj)
console.log(res) //{ a: 123, b: { m: 10 } }
```
+ Object.getOwnPropertyDescriptor
```javascript
//返回对象的某个元素的描述符
const obj = { a: 123, b: { m: 10 } }
const res = Object.getOwnPropertyDescriptor(obj, "a")
console.log(res) //{ value: 123, writable: true, enumerable: true, configurable: true }
```
+ Object.getOwnPropertyDescriptors()
```javascript
//返回对象的所有自身属性的描述符
const obj = { a: 123, b: { m: 10 } }
const res = Object.getOwnPropertyDescriptors(obj)
console.log(res) //
```
+ Object.getOwnPropertyNames
```javascript
//对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组
const obj = { a: 123, b: { m: 10 } }
const res = Object.getOwnPropertyNames(obj)
console.log(res) //[ 'a', 'b' ]
```
+ Object.getOwnPropertySymbols
```javascript
//对象的所有自身属性的属性名（只包括 Symbol 值作为名称的属性）组成的数组
const obj = { a: 123, b: { m: 10 }, [Symbol()]: 1 }
const res = Object.getOwnPropertySymbols(obj)
console.log(res) //[ Symbol() ]
```
+ Object.freeze
```javascript
//冻结一个对象，不能被修改
const obj = { a: 123, b: { m: 10 } }
Object.freeze(obj)
obj.a = 456
console.log(obj) //{ a: 123, b: { m: 10 } }
```
+ Object.getPrototypeOf
```javascript
//对象的原型
const obj = { a: 123, b: { m: 10 } }
const res = Object.getOwnPropertyNames(obj)
console.log(res) //[Object: null prototype] {}
```
+ Object.prototype.hasOwnProperty()
```javascript
//对象的是否有指定属性，不包含原型属性
const obj = { a: 123, b: { m: 10 } }
const res = obj.hasOwnProperty('a')
console.log(res) //true
```
+ Object.prototype.isPrototypeOf
```javascript
//对象是否存在于另一个对象的原型链上
const obj = { a: 123, b: { m: 10 } }
const res = obj.isPrototypeOf(Object)
console.log(res) //false
```
+ Object.is
```javascript
//判断两个值是否为同一个值
Object.is(null, undefined) //false
Object.is(NaN, NaN) //true
Object.is(+0, 0) //true
Object.is(-0, 0) //false
Object.is(+0, -0) //false
```
+ Object.keys
```javascript
//返回对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致
const obj = { a: 123, b: { m: 10 } }
const res = Object.keys(obj)
console.log(res) //[ 'a', 'b' ]
```
+ Object.values
```javascript
//返回对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同
const obj = { a: 123, b: { m: 10 } }
const res = Object.keys(obj)
console.log(res) //[ 123, { m: 10 } ]
``` 

### 8. Array 方法
+ Array.isArray —— 判断是否为数组
+ Array.of ——参数变数组
```javascript
Array.of(1,2,3) ;//[1, 2, 3]
```
+ Array.from ——类似数组或可迭代对象创建一个新的，浅拷贝的数组实例
```javascript
Array.from('foo') // ['f','o','o']
Array.from([1, 2, 3], x => x + x) //[2, 4, 6]

const set = new Set(['foo', 'bar', 'baz', 'foo'])
Array.from(set)  //['foo', 'bar', 'baz']

const map = new Map([[1, 2], [2, 4], [4, 8]])
Array.from(map) //[[1, 2], [2, 4], [4, 8]]

const mapper = new Map([['1', 'a'], ['2', 'b']])
Array.from(mapper.values()) //['a', 'b']
Array.from(mapper.keys()) //['1', '2']

Array.from([1, 2, 3], x => x + x) //[2, 4, 6]

Array.from({ length: 3 }, (_, i) => i) // [0,1,2] 序列生成器

```
+ concat ——合并两个或多个数组，不改变当前数组，返回新数组
+ pop ——从数组中删除最后一个元素，并返回该元素的值。改变数组的长度
+ push ——将一个或多个元素添加到数组的末尾，并返回该数组的新长度。改变数组的长度
+ shift ——从数组中删除第一个元素，并返回该元素的值。改变数组的长度
+ unshift ——将一个或多个元素添加到数组的开头，并返回该数组的新长度。改变数组的长度
+ splice ——删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
+ slice ——返回一个新的数组对象，由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。不改变当前数组
+ every ——数组内的所有元素是否都能通过某个指定函数的测试。返回一个布尔值
+ some ——数组内的至少有 1 个元素通过了被提供的函数测试。返回一个布尔值
+ map ——创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成
+ filter ——创建一个新数组，其包含通过所提供函数实现的测试的所有元素
+ reduce ——迭代归并
+ join ——一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，可传参数
+ sort ——元素进行排序。默认排序是将元素转换为字符串，比较它们的 UTF-16 代码，可传入自定义比较函数。改变原数组
+ reverse ——元素的位置倒叙，改变原数组
+ find ——返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined
+ findIndex ——返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1
+ indexOf ——返回在数组中可以找到一个给定元素的第一个索引。否则返回-1
+ lastIndexOf ——返回在数组中可以找到一个给定元素的最后一个索引。否则返回-1
+ includes ——判断一个数组是否包含一个指定的值，返回布尔值
+ entries ——返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对
+ values ——返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值
+ keys ——返回一个包含数组中每个索引键的Array Iterator对象
+ forEach ——对数组的每个元素执行一次给定的函数
+ copyWithin ——浅复制数组的一部分到同一数组中的另一个位置，并返回它。不改变原数组
+ toStrng —— 返回一个字符串，表示指定的数组及其元素
+ fill ——用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引
+ flat ——按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回
```javascript
const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];
console.log(arr2.flat(2));
// expected output: [0, 1, 2, [3, 4]]
```


### 9. 数组去重
+ 遍历循环判断
```javascript
function norepeat(arr) {
  for (let i = 0, len = arr.length; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (arr[i] === arr[j] || Object.is(arr[i], arr[j])) {
        arr.splice(j, 1)
      }
    }
  }
  return arr
}
//无法去除[] {} function(){}
```
+ Set
```javascript
[...new Set(arr)]
```
+ indexOf
```javascript
function norepeat(arr) {
  const newarr = []
  arr.forEach(function (item) {
    if (newarr.indexOf(item) === -1) {
      newarr.push(item)
    }
  })
  return newarr
}

function norepeat(arr) {
  const newarr = []
  arr.forEach(function (item,index) {
    if (arr.indexOf(item) === index) {
      newarr.push(item)
    }
  })
  return newarr
}

function norepeat(arr) {
return  arr.filter(function (item,index) {
    return arr.indexOf(item) === index
  })
}


//不能判断NaN
```
+ includes
```javascript
function norepeat(arr) {
  const newarr = []
  arr.forEach(function (item, index) {
    if (!newarr.includes(item)) {
      newarr.push(item)
    }
  })
  return newarr
}
```
+ Map
```javascript
function norepeat(arr) {
  const newarr = []
  const map = new Map()
  arr.forEach(function (item) {
    if (!map.has(item)) {
      newarr.push(item)
      map.set(item, true)
    }
  })
  return newarr
}
```
+ object
```javascript
function norepeat(arr) {
  const newarr = []
  const obj = {}
  arr.forEach(function (item) {
    if (!obj[item]) {
      newarr.push(item)
      obj[item] = true
    }
  })
  return newarr
}
```

### 多维数组遍历

### 浅拷贝&深拷贝

### 手写 Promise

### 手写 ajax

### 防抖和节流

### fetch、async 、await

### apply、call、bind

### 代理

### Map、Set

### 事件循环
